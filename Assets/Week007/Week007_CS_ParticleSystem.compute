#pragma kernel CSMain

float3 initVelocity;
float3 initVelocityVariant;

float initLifespan;
float initLifespanVariant;

float deltaTime;
float gravity;

float4 ColliderPlane;

int m_activeParticleCount;
int newParticleStart;
int newParticleEnd;

RWStructuredBuffer<float3> _particleNoise;
int _particleNoiseCount;

RWStructuredBuffer<float3> _particlePosition;
RWStructuredBuffer<float3> _particleVelocity;
RWStructuredBuffer<float2> _particleLifespan; // x: remain, y: total

float3 getNoise(int i) {
	return _particleNoise[(uint)i % (uint)_particleNoiseCount];
}

[numthreads(8, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID) {
	int i = (int)id.x;

	if (i >= m_activeParticleCount) return;

	if ((newParticleEnd > newParticleStart && i >= newParticleStart && i < newParticleEnd)
	 || (newParticleEnd < newParticleStart && i < newParticleEnd))
	{
	// new particle
		float3 noise = getNoise(i);
		_particlePosition[i] = float3(0,0,0);
		_particleVelocity[i] = initVelocity + initVelocityVariant * noise;
		_particleLifespan[i] = initLifespan + initLifespanVariant * noise.x;
	}
	
	_particleLifespan[i].x -= deltaTime;

	float3 oldVel = _particleVelocity[i];
	float3 oldPos = _particlePosition[i];

	float3 newVel = oldVel + float3(0, gravity, 0) * deltaTime;
	float3 newPos = oldPos + newVel * deltaTime;

	float oldD = dot(ColliderPlane.xyz, oldPos);
	float newD = dot(ColliderPlane.xyz, newPos);

	if (oldD * newD) {
		float3 mv = newD - oldD;
		float moveDis = length(mv);
		float3 v = normalize(mv);

		float planeDotV = dot(v, ColliderPlane.xyz);
		if (planeDotV > 0.0001) {
			float t = ColliderPlane.w / planeDotV;
			float3 hitPos = oldD + v * t;

			newVel = reflect(v, ColliderPlane.xyz);
			newPos = hitPos + v * (moveDis - t);
		}
	}

	_particlePosition[i] = newPos;
	_particleVelocity[i] = newVel;
}
